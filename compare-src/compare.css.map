{"mappings":"A;;;;;A;;;;;A;;;;AEufA","sources":["src/Chart.vue","src/FlamegraphNode.vue","src/App.vue"],"sourcesContent":["<template lang=\"pug\">\n.chart(\n    :style=`{\n        display:'flex',\n        flexDirection:'column',\n        alignItems:'stretch',\n        padding:'5px 60px 20px 20px',\n        border:'1px solid black',\n        margin:'5px'\n        }`\n    )\n    .groupname-title(\n        :style=`{\n            display:'flex',\n            justifyContent:'center'\n            }`\n        )\n        div {{ selectedGroupBy ? selectedGroupBy + ': ' + groupName : '' }}\n    .chartrow(\n        :style=`{\n            width:'100%',\n            display:'flex',\n            height:'240px',\n            }`\n        )\n        .yaxis(\n            style=\"display:flex\"\n            )\n            .yaxis-title(\n                :style=`{\n                    width:0,\n                    display:'flex',\n                    alignItems:'center',\n                    justifyContent: 'center',\n                    }`\n                )\n                .title(\n                    style=\"transform:rotate(-90deg)\"\n                    )  {{ selectedYAxisMeta }}\n            .yaxis-ticks(\n                :style=\"{height:'100%', width:'75px'}\"\n                )\n                svg(\n                    height=\"320px\" \n                    viewbox=\"0 0 100 100\"\n                    )\n                    //- tick marks and text\n                    template(v-for=\"ytick in yticks\")\n                        line( \n                            x1=\"70\"\n                            x2=\"75\" \n                            :y1=\"ytick[0]\" \n                            :y2=\"ytick[0]\" \n                            stroke=\"black\" \n                            stroke-width=\"1\"\n                            )\n                        text(text-anchor='end' \n                            :x='65' \n                            :y='ytick[0] + 4'\n                            )  {{ytick[1]}}\n                    //- axis line\n                    line(\n                        :x1=\"75\"\n                        :y1=\"240\"\n                        :x2=\"75\"\n                        :y2=\"0\"\n                        stroke=\"black\"\n                        pointerEvents=\"none\"\n                        )\n        .chartarea(ref='chartAreaSvg' :style=\"{flexGrow:1}\")\n            svg(\n                xmlns=\"http://www.w3.org/2000/svg\"\n                xmlns:v-on=\"http://www.w3.org/1999/v-on\"\n                width=\"100%\" \n                height=\"100%\" \n                viewbox=\" 0 100 100\"\n                v-on:mousemove=\"notifyChartHoverPosition\"\n\n                )\n                rect(\n                    width=\"100%\"\n                    height=\"100%\"\n                    fill=\"white\"\n                    v-on:click='rectClicked'\n                    )\n                //- areas curves\n                g(cursor='pointer')\n                    path(\n                        v-for=\"series in seriesList\" \n                        :fill=\"colorHash(series.key)\" \n                        :d=\"areaFunc(series)\"\n                        v-on:click=\"$emit('set-node', series.key)\"\n                        )\n                //- selection line\n                line(\n                    v-if=\"hoverX && hoverX.groupName == groupName\"\n                    :x1=\"x(hoverX.runIndex)\"\n                    :y1=\"240\"\n                    :x2=\"x(hoverX.runIndex)\"\n                    :y2=\"0\"\n                    stroke=\"black\"\n                    pointerEvents=\"none\"\n                    )\n\n    .xaxis(\n        :style=`{\n            position:\"relative\",\n            height:\"75px\",\n            marginLeft:\"75px\",\n            zIndex:0\n            }`\n        )\n        .xaxis-ticks(\n            v-for=\"(xTitle, i) in displayedXTitles\" \n            v-if=\"(i % Math.floor(runs.length/numberOfTicks)) == 0\"\n            :style=`{\n                position:'absolute',\n                left: i/(runs.length-1)*width + 'px',\n                height:'10px',\n                borderLeft:'1px solid black'\n                }`\n            )\n            span(\n                :style=`{\n                    position:'absolute',\n                    right:0,\n                    top:'10px',\n                    transformOrigin:'right',\n                    transform:'rotate(-60deg)',\n                    whiteSpace:'nowrap',\n                    maxWidth:'150px',\n                    overflow:'hidden'\n                    }`\n                ) {{ xTitle }}\n    .xaxis-title(\n        :style=`{\n            width:'100%',\n            height: '50px',\n            display: 'flex',\n            justifyContent:'center',\n            alignItems: 'flex-end'\n            }`\n        )\n        .xaxis-title-text {{ selectedXAxisMetric}}\n            \n</template>\n\n<script lang=\"ts\">\nimport Vue from 'vue'\nimport _ from \"lodash\"\nimport {stack, area} from 'd3-shape' \nimport {scaleLinear,scaleLog} from 'd3-scale' \nimport {max, ticks, zip} from 'd3-array'\nimport {timeFormat} from 'd3-time-format'\nimport {colorHash} from './functions.js'\n\nexport default Vue.extend({\n\n    data(){ return {\n        width: '100px',\n        height:'100px' \n    }},\n\n\n    props: [ 'groupName', \n             'runs', \n             'hoverX',\n             'displayedChildrenPaths',\n             'selectedXAxisMetric',\n             'selectedYAxisMeta',\n             'selectedGroupBy',\n             'selectedScaleType'\n            ],\n\n\n    methods: {\n\n        handleResize(){\n            if(this.$refs.chartAreaSvg){\n                this.width = this.$refs.chartAreaSvg.clientWidth\n                this.height = this.$refs.chartAreaSvg.clientHeight\n            }\n        },\n        notifyChartHoverPosition(event){\n            const pixelOffset = event.offsetX\n            const runIndex =  Math.round(this.x.invert(pixelOffset))\n            const groupName = this.groupName\n\n            this.$emit('chart-hover-position-changed', groupName, runIndex)\n\n        },\n        rectClicked(event){\n            this.$emit('toggle-hover-position-locked')\n\n        },\n        colorHash,\n        range: _.range,\n    },\n\n\n    computed:{\n        yticks(){\n            const yticks = ticks(0, this.maxYval, 10)\n            return zip(yticks.map(this.y), yticks)\n        },\n        seriesList(){\n            const stackFunc = stack().keys(this.displayedChildrenPaths)\n            const viewData = this.runs.map(run => {return _.fromPairs(_.map(this.displayedChildrenPaths, path => [path, run.data[path].value]))})\n            const stackData =  stackFunc(viewData)\n            return stackData\n        },\n        displayedXTitles(){\n            return this.runs.map(run => {\n\n                var encoded_title = run.meta[this.selectedXAxisMetric]\n                var is_date = !isNaN(encoded_title);\n\n                var looked_title = ST.RunDictionaryTranslator.lookupStr( encoded_title );\n                var layman_title = is_date ? encoded_title : looked_title;\n\n                const title = layman_title\n                if (['launchdate', 'launchday'].includes(this.selectedXAxisMetric)){ \n                    return timeFormat(\"%Y-%b-%d %H:%M\")(new Date(parseInt(title + '000')))\n                } \n                return title\n            })\n        },\n        numberOfTicks(){\n            return Math.min(Math.round(this.width/50), this.runs.length)\n\n        },\n        maxYval(){\n            return max(this.seriesList, d => max(d, d => d[1]))\n\n        },\n        y(){\n            const scale = this.selectedScaleType == 'linear' ? \n                scaleLinear() \n                    // domain is [0, max value of seriesList]\n                    .domain([0,  this.maxYval])\n                    .range([this.height, 0])\n                : scaleLog() \n                    // domain is [0, max value of seriesList]\n                    .domain([0.00001,  this.maxYval])\n                    .range([this.height, 0])\n                    .clamp(true)\n            return scale\n            \n        },\n        x(){\n            const scale =  scaleLinear()\n                .domain([0, this.runs.length -1])\n                .range([0, this.width])\n            return scale\n        },\n        areaFunc(){\n            return area()\n                .x((d, i) => this.x(i)) \n                .y0(d => this.y(d[0]))\n                .y1(d => this.y(d[1]))\n        },\n    },\n\n    mounted(){\n        this.handleResize()\n        window.addEventListener('resize', this.handleResize)\n    },\n\n    beforeDestroy(){\n        window.removeEventListener('resize', this.handleResize)\n    },\n})\n</script>\n<style lang=\"scss\" scoped>\n*{\n    margin:0px;\n    box-sizing: border-box;\n}\n</style>\n","<template lang=\"pug\">\n.flamenode(:style=\"{width:inclusiveWidthPercent, display:'flex', flexDirection:'column'}\")\n    .inclusive(v-if=\"!title.startsWith('--root')\" :style=\"{display:'flex', alignItems:'center', height:'25px', background:inclusiveBackground(funcPath)}\"\n              )\n        .exclusive-white-buffer( @click='handleClick(funcPath)' :style=\"{width:exclusiveWidthPercent, display:'inline-block', backgroundColor:'white', position: 'relative', border: showTopdown ?  '1px solid black' : ''}\")\n            .exclusive(:style=`{ display:'flex'\n                               , position:'relative'\n                               , alignItems:'center'\n                               , height: '25px'\n                               , backgroundColor: colorHash(funcPath)\n                               , cursor:'pointer'\n                               , width: showTopdown ? topdownData[selectedTopdownNode].flame: '100%'\n                               , border: iAmSelected ? '3px solid black' : ''\n                               }`\n                    )\n            .text(@click='handleClick(funcPath)' :style=\"{width: exclusiveWidthPercent,overflow: 'hidden', cursor:'pointer', whiteSpace:'nowrap', position:'absolute', top: '3px', left: '3px'}\" :title='title' ) {{ title }}\n\n\n    .children(:style=\"{display:'flex'}\")\n        FlamegraphNode(v-for='fp in childrenPaths(funcPath, allFuncPaths)'\n                       :runData='runData'\n                       :selectedNode='selectedNode'\n                       :selectedTopdownNode='selectedTopdownNode'\n                       :topdownData='topdownData'\n                       :showTopdown='showTopdown'\n                       :funcPath='fp'\n                       :handleClick='handleClick'\n                       )\n</template>\n\n<script>\nimport {parentPath, childrenPaths, colorHash} from './functions.js'\n\nexport default {\n    props: [ \n        'selectedNode',\n        'selectedTopdownNode',\n        'showTopdown',\n        'topdownData',\n        'runData',\n        'funcPath',\n        'handleClick',\n    ],\n\n    computed:{\n        title(){\n\n            if( !window.ST ) {\n                return \"\";\n            } else {\n\n                var encoded_title = `${this.funcPath.split('/').slice(-1)[0]} (${this.runData[this.funcPath].exclusive})`\n                var layman_title = ST.RunDictionaryTranslator.lookupStr(encoded_title);\n\n                return layman_title;\n            }\n        },\n        iAmSelected(){return this.selectedNode == this.funcPath},\n        allFuncPaths(){return Object.keys(this.runData)},\n        myInclusive(){ return this.runData[this.funcPath].inclusive },\n        exclusiveWidthPercent(){ \n            // css doesn't like a width to be 0% so if it is zero just return 0 without the %\n            if (this.myInclusive == 0) return 0\n            const width =  this.runData[this.funcPath].exclusive / this.myInclusive * 100 \n            if(width == 0) return 0\n            return width + \"%\"\n        },\n        inclusiveWidthPercent(){\n            return this.funcPath == this.selectedNode \n                     ? '100%'\n                     :  this.myInclusive / this.runData[parentPath(this.funcPath)].inclusive * 100 + '%'\n        },\n\n\n    },\n\n    methods: {\n        colorHash,\n        parentPath,\n        childrenPaths,\n        inclusiveBackground(funcPath){\n            return `repeating-linear-gradient( 45deg, #fff, #fff 10px, ${colorHash(this.funcPath)} 10px, ${colorHash(this.funcPath)} 20px)`\n        },\n    },\n    name: 'FlamegraphNode',\n}\n</script>\n<style lang=\"scss\" scoped>\n    *{\n        box-sizing: border-box;\n        margin: 0px;\n    }\n</style>\n","<template lang=\"pug\">\n#compare-window(:style=\"{display:'flex', flexDirection:'column'}\")\n    .updateCompareView(@click=\"rerenderForSelectDropdownUpdate\")\n    .sticky(:style=\"{position: 'sticky', top: 0, zIndex: 1}\")\n        .topbar(\n            :style=`{\n                backgroundColor: 'lightgray',\n                padding:'5px',\n                height:'40px',\n                display:'flex',\n                alignItems:'center',\n                }` \n            )\n            .selects(:style=\"{flex:1, display:'flex', alignItems:'center', flexWrap:'wrap'}\")\n                label(for=\"xAxis-select\" style=\"margin:5px\") X-Axis: \n                select#xAxis-select(v-model=\"xAxis\")\n                    option(v-for=\"option in xAxisList\") {{ option }}\n\n                label(for=\"aggregate-select\" style=\"margin:5px\") X-Axis Aggregate:\n                select#aggregate-select(:style=\"{marginRight: '10px'}\" v-model=\"selectedAggregateBy\")\n                    option(v-for=\"option in ['', 'sum','avg', 'min', 'max' ]\") {{ option }}\n\n                label(for=\"yAxis-select\" style=\"margin:5px\") Y-Axis: \n                select#yAxis-select(:value=\"yAxis\" @input='yAxisSelected($event.target.value)')\n                    option(v-for=\"option in yAxisList\") {{ option }}\n                    \n                label(for=\"groupBy-select\" style=\"margin:5px\") Group By:\n                select#groupBy-select(v-model=\"selectedGroupBy\")\n                    option(v-for=\"option in groupByList\") {{ option }}\n            \n            \n            .scale-type-button(\n                :style=`{\n                    borderRadius:'5px',\n                    padding:'7px',\n                    backgroundColor:'#666',\n                    color:'white',\n                    cursor:'pointer',\n                    userSelect:'none',\n                    }`\n                @click=\"toggleScaleType\"\n                ) Set {{ selectedScaleType == 'linear' ? 'Log' : 'Linear' }}\n        .legend(\n            :style=`{\n                display:'flex',\n                justifyContent:'center',\n                marginTop:'5px',\n                }`\n            ) \n            .legend-border(\n                :style=`{\n                    display:'flex',\n                    flexWrap:'wrap',\n                    maxWidth:'100%',\n                    alignItems:'center',\n                    border:'1px solid black',\n                    borderRadius:'15px',\n                    backgroundColor:'#eee',\n                    }`\n            ) \n                .legend-item(v-for=\"path in displayedChildrenPaths\"\n                    @click='togglePathVisible(path)'\n                    :style=`{\n                        display:'flex',\n                        padding:'5px',\n                        cursor:'pointer',\n                        }`\n                    ) \n                    .circle(\n                    :style=`{\n                        width:'15px',\n                        height:'15px',\n                        backgroundColor: disabledFuncPaths.includes(path) ? 'lightgrey': colorHash(path), borderRadius:'50px'\n                        }`\n                    ) \n                    .name(\n                    :style=`{\n                        marginLeft:'5px',\n                        color: disabledFuncPaths.includes(path) ? 'lightgrey': 'black'\n                        }`\n                    ) {{ legendItem(path) }}\n    .comparison-charts(style=\"padding:10px\")\n        view-chart(\n            v-for=\"(runs, groupName) in groupedAndAggregated\" \n            :groupName=\"groupName\" \n            :hoverX=\"hoverX\"\n            :runs=\"runs\" \n            :displayedChildrenPaths=\"difference(displayedChildrenPaths, disabledFuncPaths)\"\n            :selectedXAxisMetric=\"xAxis\"\n            :selectedYAxisMeta=\"yAxis\"\n            :selectedGroupBy=\"selectedGroupBy\"\n            :selectedScaleType='selectedScaleType'\n            @set-node=\"changePath\"\n            @chart-hover-position-changed=\"setChartHoverPosition\"\n            @toggle-hover-position-locked=\"toggleHoverPositionLock\"\n            )\n    .run-view(\n        v-if=\"selectedRun\" \n        :style=`{\n            width:'100%',\n            height:'270px',\n            display:'flex',\n            position:'sticky',\n            bottom: 0,\n            backgroundColor:'white',\n            padding:'10px'\n            }`\n        )\n        FlameGraph(\n            :runData='selectedRun.data' \n            :selectedNode='selectedParent' \n            :handleClick='changePath'\n            )\n        .global-meta(\n            :style=`{\n            flex: 1,\n            display:'flex',\n            flexDirection:'column',\n            minWidth:'300px',\n            maxWidth:'500px',\n            marginLeft:'20px',\n            overflow:'scroll',\n            }`\n            )\n            .metarow(\n                v-for='(metaVal, metaName) in selectedRun.meta'\n                :style=`{\n                    display:'flex',\n                    }` \n                )\n                .name(:style=\"{color:'blue', fontWeight:'bold'}\") {{ metaName }} \n                .val(:style=\"{whiteSpace:'nowrap', overflowWrap:'break-word'}\") : {{ metaVal }}\n</template>\n\n<script lang=\"ts\">\nimport Vue from \"vue\";\nimport Chart from './Chart.vue'\nimport FlameGraph from './Flamegraph.vue'\nimport _ from \"lodash\"\nimport {childrenPaths, colorHash} from './functions.js'\n\nfunction getInitialYValue(runs){\n\n      const firstRun = runs[0] || {data:{}}\n      const metrics = Object.keys(Object.values(firstRun.data)[0] || {})\n\n      var defMetric = metrics[0]\n\n    var yaxis = ST.Utility.get_param(\"yaxis\");\n\n      if( yaxis ) {\n\n          yaxis = decodeURIComponent(yaxis);\n          return yaxis;\n      }\n\n      if( defMetric === \"spot.channel\" ) {\n          return metrics[1]\n      }\n      return defMetric\n}\n\nexport default Vue.extend({\n    data() { return {\n        xAxis: 'launchdate',\n        xAxisListener: null,\n        yAxis: '',\n        yAxisListener: null,\n        selectedGroupBy: '',\n        groupByListener: null,\n        selectedAggregateBy: '',\n        filenames:[],\n        aggregateListener: null,\n        rootFuncPath: '',\n        selectedParent: \"--root path--\",\n        selectedScaleType: \"linear\",\n        hoverX: null,\n        disabledFuncPaths: [],\n        hoverLock: false,\n    }},\n    props: ['path'],\n    mounted() {\n    },\n    watch:{\n        xAxis(value){\n            if(this.xAxisListener) this.xAxisListener(value)\n        },\n        selectedGroupBy(value){\n            this.hoverX = null;\n            if(this.groupByListener) this.groupByListener(value)\n        },\n        selectedAggregateBy(value){\n            if(this.aggregateListener) this.aggregateListener(value)\n        },\n        filenames(filenames){\n            if(filenames.length){\n                const allFuncPaths = _.keys(this.runs[0].data)\n                // if no rootFuncPath set or dataset doesn't include currently set rootFuncPath set it\n                if(this.rootFuncPath == '' || !allFuncPaths.includes(this.rootFuncPath)){\n                    this.rootFuncPath = _.min(allFuncPaths)\n                }\n\n            }\n            var yax = getInitialYValue(this.runs)\n            this.yAxis = yax; //this.lookupOriginalYAxis( yax );\n        },\n    },\n    computed: {\n        runs(){\n\n            if( this && this.filenames && window.runs ) {\n\n                var fnames = this.filenames;\n                //return window.runs.filter(run => this.filenames.includes(run.meta.datapath.value));\n                var filtered_runs = window.runs.filter( function(run) {\n                    return fnames.includes(run.meta.datapath.value);\n                } );\n\n                //var localGroupedAndAggregated = this.groupedAndAggregated;\n\n/*                if( !window.doFullRuns ) {\n\n                    filtered_runs = ST.RunsMeter.meter( filtered_runs );\n\n                    setTimeout( function() {\n\n                        window.doFullRuns = 1;\n                        this.runs.push({\"filler\": 2});\n                        this.runs.pop();\n\n                        $('.updateCompareView').trigger('click');\n\n                        console.log('Trigger get full runs.');\n\n                    }, 4000 );\n                } else {\n                    console.log('Got Full.');\n                }*/\n\n                return filtered_runs;\n            }\n\n            return [];\n        },\n        xAxisList(){\n            if (this.filenames.length){\n\n                const firstRun = this.runs[0] || {meta:{}}\n                const metaKeys = Object.keys(firstRun.meta)\n\n                return metaKeys\n            } else {\n                return []\n            }\n        },\n        funcPathKeys(){\n            return this.runs[0] ? Object.keys(this.runs[0].data) : []\n        },\n        displayedChildrenPaths(){\n            var chp = childrenPaths(this.selectedParent, this.funcPathKeys)\n            console.dir(chp);\n            return chp;\n        },\n        groupByList(){\n            return [''].concat(this.xAxisList)\n        },\n        yAxisList(){\n\n            //  These are stubs meant to be replaced with the aliases we get back from the BE.\n             var aliasReplacements = {\n                \"avg#inclusive#sum#time.duration\" : \"Avg time/rank\",\n                 \"sum#inclusive#sum#time.duration\" : \"Total time\",\n                \"min#inclusive#sum#time.duration\" : \"Min time/rank\",\n                 \"max#inclusive#sum#time.duration\" : \"Max time/rank\"\n            };\n\n            if( window.cachedData ) {\n\n                var rdm = window.cachedData.RunDataMeta;\n\n                for( var encoded in rdm ) {\n\n                    if( rdm[encoded].alias ) {\n                        var alias = rdm[encoded].alias;\n                        aliasReplacements[encoded] = alias;\n                    }\n                }\n            }\n\n            window.aliasReplacements = aliasReplacements;\n\n            const firstRun = this.runs[0] || {data:{}}\n            var metrics = Object.keys(Object.values(firstRun.data)[0] || {})\n\n            console.dir(firstRun);\n\n            for( var y=0; y < metrics.length; y++ ) {\n\n                var loopMetric = metrics[y];\n\n                if( loopMetric === \"spot.channel\" ) {\n                    metrics.splice(y,1);\n                }\n\n                loopMetric = metrics[y];\n\n                for( var candidate in aliasReplacements ) {\n\n                    if( loopMetric === candidate ) {\n\n                        var replacement = aliasReplacements[candidate];\n                        metrics[y] = replacement;\n                    }\n                }\n            }\n\n            return metrics;\n        },\n        selectedRun(){\n            return this.hoverX ? this.groupedAndAggregated[this.hoverX.groupName][this.hoverX.runIndex] : null;\n        },\n        groupedAndAggregated(){\n\n            var yAxisLookup = this.lookupOriginalYAxis( this.yAxis );\n\n            var countLoops = 0;\n            var peeledMetricData;\n\n            var path = ST.Utility.get_param('sf');\n            var key = 'peeledMetricData' + path;\n            console.log('Started peeling, Using peel key: ' + key);\n\n            var localPeeled = localStorage.getItem(key);\n\n            if( localPeeled && false ) {\n                peeledMetricData = localPeeled;\n            } else {\n                peeledMetricData = _.map(this.runs, run => {\n\n                    var metaPair = _.map(run.meta, (meta, metaName) => [metaName, meta.value]);\n                    const meta = _.fromPairs(metaPair);\n\n                    var mapPair = _.map(run.data, function (metrics, funcPath) {\n\n                        var metricsFloat = parseFloat(metrics[yAxisLookup]);\n                        var pair = [funcPath, {value: metricsFloat}];\n                        countLoops++;\n\n                        return pair;\n                    });\n\n                    const data = _.fromPairs(mapPair)\n\n                    return {meta, data}\n                });\n\n                localStorage.setItem(key, peeledMetricData);\n            }\n\n            console.log( 'countLoops = ' + countLoops );\n            console.dir( peeledMetricData );\n\n            const orderedData = _.orderBy(peeledMetricData, item => {\n                const metaval = item.meta[this.xAxis]\n                return parseFloat(metaval) || metaval\n            });\n\n            const grouped = this.selectedGroupBy ? _.groupBy(orderedData, a => a.meta[this.selectedGroupBy]) : {\"all\": orderedData}\n            if(!this.selectedAggregateBy) return grouped\n\n            const aggregated = _.fromPairs(_.map(grouped, (runList, groupByName) => {\n                // consolidate the run list into a single run\n\n                //   first create a run where each value of data and meta is the list of values of all the runs of the runList\n                const aggregateGroups = _.groupBy(runList, a => a.meta[this.xAxis])\n                const aggregatedValues = _.map(aggregateGroups, (runList, aggregateBykey) => {\n                    const aggregatedRun = {\n                        data: _.fromPairs(_.map(runList[0].data, (val, key) => [key, []] )), \n                        meta: _.fromPairs(_.map(runList[0].meta, (val, key) => [key, []] )),\n                    }\n\n\n                    // create object of empty arrays\n\n                    runList.forEach(run => {\n                        _.forEach(run.meta, (val, key) => {\n                            if( aggregatedRun.meta[key] ) {\n                                aggregatedRun.meta[key].push(val);\n                            }\n                        })\n                        _.forEach(run.data, (val, key) => {\n\n                            if( aggregatedRun.data[key] ) {\n                                aggregatedRun.data[key].push(val.value);\n                            }\n\n                            // console.log('list', groupByName, key, val.value, aggregatedRun.data[key])\n                        })\n                    })\n\n                    // if the meta values are all the same that value is preserved else just mark it '--' to denote assorted values\n                    _.forEach(aggregatedRun.meta, (metaList, metaName) => {\n                        const uniqVals = _.uniq(metaList)\n                        aggregatedRun.meta[metaName] =  uniqVals.length == 1 ? uniqVals[0]: '--'\n                    })\n                    \n                    // consolidate the data values into the type of aggregate\n                    _.forEach(aggregatedRun.data, (dataList, dataName) => {\n                        switch(this.selectedAggregateBy){\n                        case 'sum':\n                            aggregatedRun.data[dataName] = { value: dataList.reduce((a, b) => a + b, 0) }\n                            break;\n                        case 'avg':\n                            aggregatedRun.data[dataName] = { value: (dataList.reduce((a, b) => a + b, 0))/dataList.length }\n                            break;\n                        case 'max':\n                            aggregatedRun.data[dataName] = { value: _.max(dataList) }\n                            break;\n                        case 'min':\n                            aggregatedRun.data[dataName] = { value: _.min(dataList) }\n                            break;\n                        }\n                    })\n\n                    // mark how many runs were consolidated\n                    aggregatedRun.meta['--num records--'] = runList.length\n                    return aggregatedRun\n                    })\n                    return [groupByName, aggregatedValues]\n                    \n                }))\n\n            console.log('finished aggregated...');\n            return aggregated\n        },\n    },  // end computed\n\n    methods:{\n        legendItem( path ) {\n\n            var ret = path.slice(path.lastIndexOf('/') + 1);\n\n            var layman_title = ST.RunDictionaryTranslator.lookupStr( ret );\n            return layman_title;\n        },\n        //  Returns the original yAxis that looks like this \"max#inclusive#duration.time\"\n        //  the data was originally sent to the FE with those as indexes.\n        lookupOriginalYAxis( yAxis ) {\n\n            var yax = yAxis;\n\n            for( var encoded in window.aliasReplacements ) {\n\n                var alias = window.aliasReplacements[ encoded ];\n                if( alias === yAxis ) {\n                    yax = encoded;\n                }\n            }\n\n            return yax;\n        },\n        yAxisSelected(selectedYAxis){\n\n            this.yAxis = selectedYAxis\n\n            if(this.yAxisListener) {\n                this.yAxisListener(selectedYAxis);\n            }\n        },\n        changePath(path){\n        this.selectedParent = path\n        },\n        rerenderForSelectDropdownUpdate() {\n            this.filenames.push(\"test823\");\n        },\n        toggleScaleType(){\n            this.selectedScaleType = this.selectedScaleType == 'linear' ? 'log' : 'linear'\n            this.filenames.push(\"test13241234.cali\");\n        },\n        togglePathVisible(pathToToggle){\n        this.disabledFuncPaths =  _.xor(this.disabledFuncPaths, [pathToToggle])\n        },\n        difference: _.difference,\n        colorHash,\n        setChartHoverPosition(groupName, runIndex){\n        if(!this.hoverLock){\n            this.hoverX = {groupName, runIndex}\n        }\n        },\n        toggleHoverPositionLock(){\n        this.hoverLock = !this.hoverLock\n        },\n    },\n    components: {\n        viewChart: Chart,\n        FlameGraph\n    }\n})\n</script>\n\n<style lang=\"scss\" scoped>\nselect{\n  margin-right: 10px;\n}\n*{\n  font-family: Verdana, Geneva, Tahoma, sans-serif;\n  font-size: 8pt;\n  margin: 0px;\n  box-sizing:border-box;\n}\n\n</style>\n"],"names":[],"version":3,"file":"compare.css.map","sourceRoot":"/"}